<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="app.css" />
    <script src="https://static.opentok.com/v2/js/opentok.min.js"></script>

    <script src="index.js"></script>
    <title>Host view</title>
  </head>
  <body>
    <h1>This is the host view</h1>
    <div id="controls">
      <!-- <div class="iconButton" id="cameraButton"> -->
      <button class="iconButton" id="cameraButton">
        <img
          src="./icons/camera-video-fill.svg"
          id="cameraIcon"
          alt=""
          width="100%"
        />
      </button>

      <button class="iconButton" id="micButton">
        <img src="./icons/mic-fill.svg" id="micIcon" alt="" width="100%" />
      </button>

      <div><progress id="progress" max="100" value="0"> </progress></div>

      <button class="iconButton" id="endCallButton">
        <img
          src="./icons/telephone-x-fill.svg"
          id="endCallIcon"
          alt=""
          width="100%"
        />
      </button>
    </div>

    <div id="publisher"></div>
    <div id="subscribers"></div>
  </body>
  <script>
    const basicUrl = 'http://localhost:3000';
    let roomApiKey;
    let roomSessionId;
    let roomToken;
    let session = null;
    let publisher = null;
    let isPublishing = false;

    async function getCredentials() {
      try {
        const url = `/api/room/${roomName}?role=admin`;
        const config = {};
        const response = await fetch(`${basicUrl}${url}`, config);
        const data = await response.json();
        console.log(data);
        if (data.apiKey && data.sessionId && data.token) {
          roomApiKey = data.apiKey;
          roomSessionId = data.sessionId;
          roomToken = data.token;
          return Promise.resolve(data);
        }
      } catch (error) {
        console.log(error.message);
        return Promise.reject(error);
      }
    }

    getCredentials().then(data => {
      initializeSession(data);
    });

    function initializeSession(data) {
      const { apiKey, sessionId, token } = data;
      session = OT.initSession(apiKey, sessionId);

      session.on('connectionCreated', function(event) {
        connectionCount += 1;
        usersConnected.push(event.connection);
        console.log(usersConnected);
        console.log('[connectionCreated]', connectionCount);

        // console.log(isHostPresent());

        // handlePublisher(publisher);
      });

      session.on('connectionDestroyed', function(event) {
        connectionCount -= 1;
        console.log('[connectionDestroyed]', connectionCount);
        usersConnected.filter(
          connection => connection.id != event.connection.id
        );
        console.log(usersConnected);

        // handlePublisher(publisher);
      });

      // Subscribe to a newly created stream
      session.on('streamCreated', function streamCreated(event) {
        const subscriberOptions = {
          insertMode: 'append',
          width: '60%',
          height: '60%'
        };
        session.subscribe(
          event.stream,
          'subscribers',
          subscriberOptions,
          handleError
        );
      });

      session.on('sessionDisconnected', function sessionDisconnected(event) {
        console.log('You were disconnected from the session.', event.reason);
      });

      // initialize the publisher
      var publisherOptions = {
        insertMode: 'append',
        width: '100%',
        height: '100%',
        publishAudio: false,
        publishVideo: false
      };
      publisher = OT.initPublisher('publisher', publisherOptions, handleError);
      publisher.on('streamCreated', event => {
        console.log('[Publisher] - streamCreated', event);
        isPublishing = true;
      });
      publisher.on('streamDestroyed', event => {
        console.log('[Publisher] - streamDestroyed', event.reason);
        event.preventDefault();
        // isPublishing = false;
      });

      // Connect to the session
      session.connect(token, function callback(error) {
        if (error) {
          handleError(error);
        } else {
          handlePublisher(publisher);
          console.log('Session Connected');
        }
      });
    }

    function handlePublisher(pub) {
      console.log('[handlePublish]', pub);
      if (!isPublishing) {
        // todo publish twice the same stream explode everything
        session.publish(pub, handleError);
      } else if (connectionCount === 0 && pub) {
        session.unpublish(pub);
      }
    }

    const disconnectAll = () => {
      usersConnected.map(connection => {
        console.log('disconnecting ' + connection);
        session.forceDisconnect(connection);
      });
    };

    document.getElementById('endCallButton').addEventListener('click', () => {
      disconnectAll();
    });
  </script>
</html>
